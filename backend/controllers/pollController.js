// server/controllers/pollController.js
const Poll = require('../models/Poll');
const Vote = require('../models/Vote'); // Make sure this is used or remove if not
const User = require('../models/User'); // Needed if you want to fetch displayName fresh
const mongoose = require('mongoose');
const qrcode = require('qrcode');
const asyncHandler = require('express-async-handler'); // Using asyncHandler
const Notification = require('../models/Notification');
const sendEmail = require('../utils/sendEmail'); 
exports.createPoll = asyncHandler(async (req, res) => {
    const { question, options, isPublic, votingType, voteRestriction, expiresAt, showResults, allowMultipleChoices, allowedVoters,allowDeadlineLater } = req.body;
    let pollStatus = 'active'; // Default to active
    let finalExpiresAt = expiresAt;
    if (!isPublic && allowDeadlineLater) {
        pollStatus = 'scheduled'; // Override if private and deadline later
        finalExpiresAt = null;
    }
    if (!question || !options || !Array.isArray(options) || options.length < 2) {
        res.status(400); // Bad Request
        throw new Error('Question and at least two options (as an array) are required.');
    }

    // Ensure req.user exists (from protect middleware)
    if (!req.user || !req.user.id) {
        res.status(401); // Unauthorized
        throw new Error('User not authenticated or user ID missing.');
    }
    // --- DEFINE creatorId HERE, from req.user ---
    const creatorId = req.user.id; 
    // --- AND get creatorDisplayName for notifications that need it immediately ---
    let creatorDisplayNameForNotifications = req.user.displayName;
    if (!creatorDisplayNameForNotifications) { // Fallback if not on req.user directly
        const creatorDetails = await User.findById(creatorId).select('displayName');
        if (creatorDetails) {
            creatorDisplayNameForNotifications = creatorDetails.displayName;
        } else {
            creatorDisplayNameForNotifications = 'A Poll Creator'; // Generic fallback
        }
    }
    const pollOptions = options.map(opt => ({
        text: typeof opt === 'string' ? opt.trim() : (opt && typeof opt.text === 'string' ? opt.text.trim() : ''),
        votes: 0
    })).filter(opt => opt.text); // Filter out any empty options after processing

    if (pollOptions.length < 2) {
        res.status(400);
        throw new Error('At least two valid (non-empty) options are required.');
    }

    const newPoll = new Poll({
        question,
        options: pollOptions,
        creator: creatorId,
        isPublic,
        votingType: !isPublic ? 'authenticated' : (votingType || 'anonymous'), // Sensible defaults
        voteRestriction: !isPublic ? 'email' : (voteRestriction || 'none'), // Sensible defaults
        showResults: showResults || 'always', // Default
        allowMultipleChoices: allowMultipleChoices || false,
        allowedVoters: isPublic ? [] : (allowedVoters || []).map(email => email.toLowerCase().trim()).filter(Boolean),
        status: pollStatus, // status is explicitly set here
        expiresAt: finalExpiresAt,
        allowDeadlineLater: !isPublic && allowDeadlineLater,
 
    });

    // Generate QR Code
    // The shortId is generated by default by the Poll model if you used shortid.generate
    const pollUrl = `${process.env.CLIENT_URL}/poll/${newPoll.shortId}`;
    try {
        newPoll.qrCodeUrl = await qrcode.toDataURL(pollUrl);
    } catch (qrError) {
        console.error("Error generating QR code:", qrError);
        // Decide if this is a critical error. For now, we'll proceed without it.
        // You might want to throw an error or set qrCodeUrl to null.
    }

    const savedPoll = await newPoll.save();

    // Populate creator display name for the notification
    // This ensures we have the displayName even if not initially on req.user object
    // Or, ensure your 'protect' middleware populates req.user.displayName
    let creatorDisplayName = req.user.displayName;
    if (!creatorDisplayName && req.user.id) {
        const creatorDetails = await User.findById(req.user.id).select('displayName');
        if (creatorDetails) {
            creatorDisplayName = creatorDetails.displayName;
        } else {
            creatorDisplayName = 'A user'; // Fallback if user somehow not found
        }
    }


    if (!savedPoll.isPublic && savedPoll.allowedVoters && savedPoll.allowedVoters.length > 0) {
        const creator = await User.findById(creatorId).select('displayName');
        const creatorName = creator ? creator.displayName : 'The poll creator';
        const creatorNameToDisplay = creatorDisplayNameForNotifications;

        for (const invitedEmail of savedPoll.allowedVoters) { // Iterate through the emails provided
            const invitedUser = await User.findOne({ email: invitedEmail.toLowerCase() }); // Find user by this email

            if (invitedUser && invitedUser._id.toString() !== creatorId.toString()) {
                // 1. Create In-App Notification
                await Notification.create({
                    userId: invitedUser._id,
                    message: `${creatorName} has invited you to vote in the poll: "${savedPoll.question}"`,
                    link: `/poll/${savedPoll.shortId || savedPoll._id}`,
                    relatedPollId: savedPoll._id
                });

                // 2. Emit Socket Event
                if (req.io) {
                     req.io.emit('poll_invitation_sent', { 
                        invitedUserId: invitedUser._id.toString(),
                        pollId: savedPoll._id.toString(),
                        pollShortId: savedPoll.shortId,
                        pollQuestion: savedPoll.question,
                        creatorName: creatorName
                     });
                }

                // --- START: Send Email Notification ---
                try {
                    const emailMessage = `
                        <h1>You're Invited to a Poll!</h1>
                        <p>Hi ${invitedUser.displayName || 'User'},</p>
                        <p>${creatorNameToDisplay} has invited you to participate in the private poll titled: <strong>"${savedPoll.question}"</strong>.</p>
                        <p>Click the link below to view the poll and cast your vote:</p>
                        <a href="${pollUrl}" target="_blank" style="display: inline-block; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px;">
                            Vote in Poll: ${savedPoll.question}
                        </a>
                        <p>If you did not expect this invitation, you can ignore this email.</p>
                        <br>
                        <p>Thanks,<br>The PollingApp Team</p>
                    `;
                    
                    await sendEmail({
                        to: invitedUser.email, // Send to the invited user's email
                        subject: `You've been invited to a poll by ${creatorNameToDisplay}: "${savedPoll.question}"`,
                        text: `Hi ${invitedUser.displayName || 'User'},\n\n${creatorNameToDisplay} has invited you to participate in the private poll: "${savedPoll.question}".\n\nView and vote here: ${pollUrl}\n\nThanks,\nThe PollingApp Team`,
                        html: emailMessage
                    });
                    console.log(`Email invitation sent to ${invitedUser.email} for poll "${savedPoll.question}"`);
                } catch (emailError) {
                    console.error(`Failed to send email invitation to ${invitedUser.email}:`, emailError);
                    // Decide if this failure is critical. For now, we log and continue.
                    // You might want to add specific error handling or retry logic here.
                }
                // --- END: Send Email Notification ---

            } else if (!invitedUser) {
                // Optional: Handle cases where an email in allowedVoters doesn't correspond to a registered user.
                // You might:
                // 1. Ignore it.
                // 2. Send a generic "You've been invited to a poll, sign up to participate" email.
                // 3. Store these emails somewhere for future "pending invitations" if the user registers later.
                // For now, we'll just log it.
                console.log(`No registered user found for email: ${invitedEmail}. No invitation email sent.`);
            }
        }
    }
    // --- END: Notify allowed voters ---


    if (savedPoll.isPublic && req.io) { // Existing public poll notification
         let creatorDisplayName = req.user.displayName;
         if (!creatorDisplayName && req.user.id) { 
            const creatorDetails = await User.findById(req.user.id).select('displayName');
            if (creatorDetails) creatorDisplayName = creatorDetails.displayName;
         }
         const publicPollNotification = {
            _id: savedPoll._id.toString(),
            creatorName: creatorDisplayNameForNotifications || 'A user',
            shortId: savedPoll.shortId,
            question: savedPoll.question,
            creatorName: creatorDisplayName || 'A user',
            createdAt: savedPoll.createdAt.toISOString(),
            options: savedPoll.options.map(opt => ({ text: opt.text, _id: opt._id.toString() })),
         };
         req.io.emit('new_public_poll', publicPollNotification);
    }

    res.status(201).json(savedPoll);
});



// ... (rest of your existing pollController code: getPolls, getPollById, castVote, updatePoll, deletePoll) ...
// Ensure all these functions are also wrapped with asyncHandler if they perform async operations,
// or have proper try/catch blocks.

exports.getPolls = asyncHandler(async (req, res) => {
    const polls = await Poll.find({
        isPublic: true,
        $or: [
            { expiresAt: { $gt: new Date() } },
            { expiresAt: null },
            { expiresAt: { $exists: false } } // Include polls where expiresAt is not set
        ]
    })
    .populate('creator', 'displayName email')
    .sort({ createdAt: -1 });
    res.json(polls);
});

// backend/controllers/pollController.js
exports.getPollById = asyncHandler(async (req, res) => {
    const identifier = req.params.id;
    let poll;

    if (mongoose.Types.ObjectId.isValid(identifier)) {
        poll = await Poll.findById(identifier).populate('creator', 'displayName email');
    }
    if (!poll) {
        poll = await Poll.findOne({ shortId: identifier }).populate('creator', 'displayName email');
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found');
    }

    // --- START: Access Control for Private Polls ---
    if (!poll.isPublic) {
        if (!req.user) { // User must be logged in to view any private poll
            res.status(401);
            throw new Error('Authentication required to view this private poll.');
        }
        const isCreator = poll.creator && poll.creator._id.toString() === req.user.id.toString();
        const isAdmin = req.user.role === 'admin';
        // req.user.email should be populated by the 'protect' middleware or fetched if not directly available
        const isAllowedVoter = poll.allowedVoters.includes(req.user.email ? req.user.email.toLowerCase() : '');

        if (!isCreator && !isAdmin && !isAllowedVoter) {
            res.status(403); // Forbidden
            throw new Error("You don't have access to this poll.");
        }
    }
    // --- END: Access Control for Private Polls ---

    res.json(poll);
});
exports.castVote = asyncHandler(async (req, res) => {
    const { optionIndex } = req.body;
    const pollId = req.params.id; // This is an identifier (_id or shortId)

    let pollToVoteOn;
    if (mongoose.Types.ObjectId.isValid(pollId)) {
        pollToVoteOn = await Poll.findById(pollId);
    }
    if (!pollToVoteOn) {
        pollToVoteOn = await Poll.findOne({ shortId: pollId });
    }

    if (!pollToVoteOn) {
        res.status(404);
        throw new Error('Poll not found.');
    }
    if (!pollToVoteOn.isPublic) {
        if (!req.user) { // User must be logged in
            res.status(401);
            throw new Error('Authentication required to vote in this private poll.');
        }
        const isCreator = pollToVoteOn.creator.toString() === req.user.id; // Creator might be allowed to vote
        const isAdmin = req.user.role === 'admin'; // Admin might be allowed
        const isAllowedVoter = pollToVoteOn.allowedVoters.includes(req.user.email ? req.user.email.toLowerCase() : '');

        // If you DON'T want creator/admin to vote unless explicitly in allowedVoters, remove them from condition:
        if (!isAllowedVoter && !isCreator && !isAdmin) { 
            res.status(403);
            throw new Error('You are not authorized to vote in this private poll.');
        }
        // Ensure the voting type for private polls is 'authenticated'
        if (pollToVoteOn.votingType !== 'authenticated') {
            // This should ideally be set at poll creation for private polls with allowedVoters
            res.status(400);
            throw new Error('Private polls with specific voters require authenticated voting type.');
        }
    }
    if (pollToVoteOn.expiresAt && new Date(pollToVoteOn.expiresAt) < new Date()) {
        res.status(400);
        throw new Error('This poll has expired.');
    }
    if (optionIndex === undefined || optionIndex < 0 || optionIndex >= pollToVoteOn.options.length) {
        res.status(400);
        throw new Error('Invalid option selected.');
    }

    let voterIdentifier;
    const isAuthenticatedPoll = pollToVoteOn.votingType === 'authenticated';

    if (isAuthenticatedPoll) {
        if (!req.user) { // req.user should be set by 'protect' middleware if this route is protected
            res.status(401);
            throw new Error('Authentication required to vote in this poll.');
        }
        voterIdentifier = req.user.id;
    } else { // anonymous
        if (pollToVoteOn.voteRestriction === 'ip') {
            voterIdentifier = req.ip;
        } else {
            voterIdentifier = req.ip; // Or another anonymous identifier
        }
    }

    // Check for existing vote only if restriction is not 'none'
    // AND (if it's an authenticated poll OR if it's an anonymous poll with IP restriction)
    if (pollToVoteOn.voteRestriction !== 'none' && (isAuthenticatedPoll || pollToVoteOn.voteRestriction === 'ip')) {
        const existingVote = await Vote.findOne({ poll: pollToVoteOn._id, voterIdentifier });
        if (existingVote) {
            res.status(403); // Forbidden
            throw new Error('You have already voted in this poll.');
        }
    }

    await Vote.create({
        poll: pollToVoteOn._id,
        optionIndex: optionIndex,
        voterIdentifier: voterIdentifier
    });

    // Atomically increment the vote count on the specific option
    const updatedPoll = await Poll.findOneAndUpdate(
        { _id: pollToVoteOn._id, "options._id": pollToVoteOn.options[optionIndex]._id },
        { $inc: { "options.$.votes": 1 } },
        { new: true }
    ).populate('creator', 'displayName email');

    if (!updatedPoll) {
        // This should ideally not happen if the poll and option exist
        res.status(500);
        throw new Error('Failed to update vote count on the poll.');
    }

    // Emit real-time update for this specific poll's results
    if (req.io) {
        req.io.to(updatedPoll._id.toString()).emit('vote_update', updatedPoll); // Emit to specific poll room
        req.io.to(updatedPoll.shortId).emit('vote_update', updatedPoll);      // Also emit to shortId room
        console.log(`Emitted vote_update for poll: ${updatedPoll.question}`);
    }


    res.json(updatedPoll);
});


exports.updatePoll = asyncHandler(async (req, res) => {
    // ... (Your existing logic, ensure it's robust) ...
    // Find poll by _id or shortId similarly to getPollById or castVote
    const identifier = req.params.id;
    let poll;
    if (mongoose.Types.ObjectId.isValid(identifier)) {
        poll = await Poll.findById(identifier);
    }
    if (!poll) {
        poll = await Poll.findOne({ shortId: identifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found');
    }

    if (poll.creator.toString() !== req.user.id && req.user.role !== 'admin') {
        res.status(403);
        throw new Error('User not authorized to update this poll');
    }

    const { question, options, isPublic, expiresAt } = req.body; // Add other fields as needed
    if (question !== undefined) poll.question = question;
    if (isPublic !== undefined) poll.isPublic = isPublic;
    if (expiresAt !== undefined) poll.expiresAt = expiresAt; // Allow setting to null
    
    if (options && Array.isArray(options)) {
        // More robust option update: preserve existing votes if option text matches,
        // or reset votes if options are completely new. For simplicity:
        poll.options = options.map(opt => ({ 
            text: typeof opt === 'string' ? opt.trim() : (opt && typeof opt.text === 'string' ? opt.text.trim() : ''),
            votes: parseInt(opt.votes) || 0 // Ensure votes are numbers
        })).filter(opt => opt.text);
         if (poll.options.length < 2) {
            res.status(400);
            throw new Error('Poll must have at least two valid options after update.');
        }
    }

    const updatedPoll = await poll.save();
    res.json(updatedPoll);
});

exports.deletePoll = asyncHandler(async (req, res) => {
    const pollIdentifier = req.params.id;
    let poll;

    if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
        poll = await Poll.findById(pollIdentifier);
    }
    if (!poll && !mongoose.Types.ObjectId.isValid(pollIdentifier)) { // Only try shortId if it's not an ObjectId
        poll = await Poll.findOne({ shortId: pollIdentifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found with the given identifier.');
    }

    if (poll.creator.toString() !== req.user.id && req.user.role !== 'admin') {
        res.status(403);
        throw new Error('User not authorized to delete this poll.');
    }

    await Vote.deleteMany({ poll: poll._id }); // Delete associated votes
    await Poll.deleteOne({ _id: poll._id });

    res.json({ message: 'Poll deleted successfully' });
});

// server/controllers/pollController.js
// ... (other imports: Poll, Vote, mongoose, asyncHandler) ...
  exports.stopPoll = asyncHandler(async (req, res) => {
      const pollIdentifier = req.params.id;
      let poll;
      // ... (logic to find poll by identifier) ...
        if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
            poll = await Poll.findById(pollIdentifier);
        }
        if (!poll && !mongoose.Types.ObjectId.isValid(pollIdentifier)) {
            poll = await Poll.findOne({ shortId: pollIdentifier });
        }

        if (!poll) { /* ... handle not found ... */ }
        if (poll.creator.toString() !== req.user.id) { /* ... handle unauthorized ... */ }
        if (poll.status === 'closed') { /* ... handle already closed ... */ }

      poll.status = 'closed';
      poll.expiresAt = new Date();
      const updatedPoll = await poll.save();

      // --- Create Notifications & Prepare for Socket Emit ---
      const votes = await Vote.find({ poll: poll._id }).select('voterIdentifier').lean(); // .lean() for plain JS objects
      // Ensure voterIdentifier stores user._id for authenticated votes
      const voterUserIds = [...new Set( // Get unique voter IDs
          votes
            .map(v => v.voterIdentifier) // Get all voterIdentifiers
            .filter(id => mongoose.Types.ObjectId.isValid(id)) // Filter out invalid ones
            .map(id => id.toString()) // Convert to string for consistent comparison
      )];
      
      const usersToNotifyIds = [poll.creator.toString()]; // Start with the creator
      
      for (const userIdStr of voterUserIds) {
          // Create DB Notification for each voter (excluding creator if they also voted, handled by Set later)
          if (userIdStr !== poll.creator.toString() && !usersToNotifyIds.includes(userIdStr)) {
              usersToNotifyIds.push(userIdStr); // Add to list for socket emit
              await Notification.create({
                  userId: userIdStr, // Should be ObjectId here
                  message: `Results for the poll "${poll.question}" you voted in are now published!`,
                  link: `/poll/${poll.shortId || poll._id}/results`,
                  relatedPollId: poll._id
              });
              console.log(`DB Notification created for user ${userIdStr} for poll ${poll._id}`);
          }
      }
      // Ensure creator gets a DB notification if they didn't vote or if you want a specific one
      // (The current logic adds creator to usersToNotifyIds for socket, DB notification for creator can be separate)
      if (!voterUserIds.includes(poll.creator.toString())) {
         await Notification.create({
            userId: poll.creator,
            message: `Results for your poll "${poll.question}" are now published (you closed it).`,
            link: `/poll/${poll.shortId || poll._id}/results`,
            relatedPollId: poll._id
         });
      }
      // --- End DB Notification Creation ---


      // Emit a general 'poll_closed' event for UI updates on voting/results pages
      if (req.io) {
          const pollClosedEventData = { /* ... as before ... */ };
          req.io.to(updatedPoll._id.toString()).emit('poll_closed', pollClosedEventData);
          if (updatedPoll.shortId) req.io.to(updatedPoll.shortId).emit('poll_closed', pollClosedEventData);
          
          // Emit 'results_published_for_poll' for toast notifications
          const resultsPublishedEventData = {
              pollId: updatedPoll._id.toString(),
              pollShortId: updatedPoll.shortId,
              pollQuestion: updatedPoll.question,
              notifiedUserIds: [...new Set(usersToNotifyIds)] // Ensure unique list of user IDs
          };
          req.io.emit('results_published_for_poll', resultsPublishedEventData);
          console.log(`Emitted 'results_published_for_poll' for poll: ${updatedPoll.question} to users: ${usersToNotifyIds.join(', ')}`);
      }

      res.json(updatedPoll);
  });
  exports.getUserVoteStatus = asyncHandler(async (req, res) => {
    const pollIdentifier = req.params.id;
    let poll;

    // Find the poll by _id or shortId
    if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
        poll = await Poll.findById(pollIdentifier);
    }
    if (!poll) {
        poll = await Poll.findOne({ shortId: pollIdentifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found');
    }

    // req.user.id is from the 'protect' middleware
    const existingVote = await Vote.findOne({
        poll: poll._id,
        voterIdentifier: req.user.id // For authenticated users, voterIdentifier is their ID
    });

    res.json({ hasVoted: !!existingVote });
});
