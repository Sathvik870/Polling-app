// server/controllers/pollController.js
const Poll = require('../models/Poll');
const Vote = require('../models/Vote'); // Make sure this is used or remove if not
const User = require('../models/User'); // Needed if you want to fetch displayName fresh
const mongoose = require('mongoose');
const qrcode = require('qrcode');
const asyncHandler = require('express-async-handler'); // Using asyncHandler
const Notification = require('../models/Notification');
exports.createPoll = asyncHandler(async (req, res) => {
    const { question, options, isPublic, votingType, voteRestriction, expiresAt, showResults, allowMultipleChoices, allowedVoters,allowDeadlineLater } = req.body;
    let pollStatus = 'active'; // Default to active
    let finalExpiresAt = expiresAt;
    if (!isPublic && allowDeadlineLater) {
        pollStatus = 'scheduled'; // Override if private and deadline later
        finalExpiresAt = null;
    }
    if (!question || !options || !Array.isArray(options) || options.length < 2) {
        res.status(400); // Bad Request
        throw new Error('Question and at least two options (as an array) are required.');
    }

    // Ensure req.user exists (from protect middleware)
    if (!req.user || !req.user.id) {
        res.status(401); // Unauthorized
        throw new Error('User not authenticated or user ID missing.');
    }

    const pollOptions = options.map(opt => ({
        text: typeof opt === 'string' ? opt.trim() : (opt && typeof opt.text === 'string' ? opt.text.trim() : ''),
        votes: 0
    })).filter(opt => opt.text); // Filter out any empty options after processing

    if (pollOptions.length < 2) {
        res.status(400);
        throw new Error('At least two valid (non-empty) options are required.');
    }

    const newPoll = new Poll({
        question,
        options: pollOptions,
        creator: req.user.id,
        isPublic,
        votingType: votingType || (isPublic ? 'anonymous' : 'authenticated'), // Sensible defaults
        voteRestriction: voteRestriction || (isPublic && votingType === 'anonymous' ? 'none' : 'email'), // Sensible defaults
        showResults: showResults || 'always', // Default
        allowMultipleChoices: allowMultipleChoices || false,
        allowedVoters: isPublic ? [] : (allowedVoters || []),
        status: pollStatus, // status is explicitly set here
        expiresAt: finalExpiresAt,
        allowDeadlineLater: !isPublic && allowDeadlineLater,
    });

    // Generate QR Code
    // The shortId is generated by default by the Poll model if you used shortid.generate
    const pollUrl = `${process.env.CLIENT_URL}/poll/${newPoll.shortId}`;
    try {
        newPoll.qrCodeUrl = await qrcode.toDataURL(pollUrl);
    } catch (qrError) {
        console.error("Error generating QR code:", qrError);
        // Decide if this is a critical error. For now, we'll proceed without it.
        // You might want to throw an error or set qrCodeUrl to null.
    }

    const savedPoll = await newPoll.save();

    // Populate creator display name for the notification
    // This ensures we have the displayName even if not initially on req.user object
    // Or, ensure your 'protect' middleware populates req.user.displayName
    let creatorDisplayName = req.user.displayName;
    if (!creatorDisplayName && req.user.id) {
        const creatorDetails = await User.findById(req.user.id).select('displayName');
        if (creatorDetails) {
            creatorDisplayName = creatorDetails.displayName;
        } else {
            creatorDisplayName = 'A user'; // Fallback if user somehow not found
        }
    }


    if (savedPoll.isPublic) {
        const publicPollNotification = {
            _id: savedPoll._id.toString(), // Send as string
            shortId: savedPoll.shortId,
            question: savedPoll.question,
            creatorName: creatorDisplayName || 'A user', // Use the fetched or existing displayName
            createdAt: savedPoll.createdAt.toISOString(),
            options: savedPoll.options.map(opt => ({ text: opt.text, _id: opt._id.toString() })), // Send lean options for PollCard
            // Add any other fields your frontend PollCard might expect for a new poll
        };
        // req.io is available if you set it up in server.js middleware
        if (req.io) { // Check if io is attached to req
            req.io.emit('new_public_poll', publicPollNotification);
            console.log('Emitted new_public_poll event for:', savedPoll.question);
        } else {
            console.warn('Socket.io (req.io) not available on request object. Cannot emit new_public_poll.');
        }
    }

    // Send response ONCE after all operations
    res.status(201).json(savedPoll);
});


// ... (rest of your existing pollController code: getPolls, getPollById, castVote, updatePoll, deletePoll) ...
// Ensure all these functions are also wrapped with asyncHandler if they perform async operations,
// or have proper try/catch blocks.

exports.getPolls = asyncHandler(async (req, res) => {
    const polls = await Poll.find({
        isPublic: true,
        $or: [
            { expiresAt: { $gt: new Date() } },
            { expiresAt: null },
            { expiresAt: { $exists: false } } // Include polls where expiresAt is not set
        ]
    })
    .populate('creator', 'displayName email')
    .sort({ createdAt: -1 });
    res.json(polls);
});

exports.getPollById = asyncHandler(async (req, res) => {
    const identifier = req.params.id;
    let poll;

    if (mongoose.Types.ObjectId.isValid(identifier)) {
        poll = await Poll.findById(identifier).populate('creator', 'displayName email');
    }
    if (!poll) { // If not found by ID or if identifier was not an ObjectId
        poll = await Poll.findOne({ shortId: identifier }).populate('creator', 'displayName email');
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found');
    }
    res.json(poll);
});

exports.castVote = asyncHandler(async (req, res) => {
    const { optionIndex } = req.body;
    const pollId = req.params.id; // This is an identifier (_id or shortId)

    let pollToVoteOn;
    if (mongoose.Types.ObjectId.isValid(pollId)) {
        pollToVoteOn = await Poll.findById(pollId);
    }
    if (!pollToVoteOn) {
        pollToVoteOn = await Poll.findOne({ shortId: pollId });
    }

    if (!pollToVoteOn) {
        res.status(404);
        throw new Error('Poll not found.');
    }

    if (pollToVoteOn.expiresAt && new Date(pollToVoteOn.expiresAt) < new Date()) {
        res.status(400);
        throw new Error('This poll has expired.');
    }
    if (optionIndex === undefined || optionIndex < 0 || optionIndex >= pollToVoteOn.options.length) {
        res.status(400);
        throw new Error('Invalid option selected.');
    }

    let voterIdentifier;
    const isAuthenticatedPoll = pollToVoteOn.votingType === 'authenticated';

    if (isAuthenticatedPoll) {
        if (!req.user) { // req.user should be set by 'protect' middleware if this route is protected
            res.status(401);
            throw new Error('Authentication required to vote in this poll.');
        }
        voterIdentifier = req.user.id;
    } else { // anonymous
        if (pollToVoteOn.voteRestriction === 'ip') {
            voterIdentifier = req.ip;
        } else {
            voterIdentifier = req.ip; // Or another anonymous identifier
        }
    }

    // Check for existing vote only if restriction is not 'none'
    // AND (if it's an authenticated poll OR if it's an anonymous poll with IP restriction)
    if (pollToVoteOn.voteRestriction !== 'none' && (isAuthenticatedPoll || pollToVoteOn.voteRestriction === 'ip')) {
        const existingVote = await Vote.findOne({ poll: pollToVoteOn._id, voterIdentifier });
        if (existingVote) {
            res.status(403); // Forbidden
            throw new Error('You have already voted in this poll.');
        }
    }

    await Vote.create({
        poll: pollToVoteOn._id,
        optionIndex: optionIndex,
        voterIdentifier: voterIdentifier
    });

    // Atomically increment the vote count on the specific option
    const updatedPoll = await Poll.findOneAndUpdate(
        { _id: pollToVoteOn._id, "options._id": pollToVoteOn.options[optionIndex]._id },
        { $inc: { "options.$.votes": 1 } },
        { new: true }
    ).populate('creator', 'displayName email');

    if (!updatedPoll) {
        // This should ideally not happen if the poll and option exist
        res.status(500);
        throw new Error('Failed to update vote count on the poll.');
    }

    // Emit real-time update for this specific poll's results
    if (req.io) {
        req.io.to(updatedPoll._id.toString()).emit('vote_update', updatedPoll); // Emit to specific poll room
        req.io.to(updatedPoll.shortId).emit('vote_update', updatedPoll);      // Also emit to shortId room
        console.log(`Emitted vote_update for poll: ${updatedPoll.question}`);
    }


    res.json(updatedPoll);
});


exports.updatePoll = asyncHandler(async (req, res) => {
    // ... (Your existing logic, ensure it's robust) ...
    // Find poll by _id or shortId similarly to getPollById or castVote
    const identifier = req.params.id;
    let poll;
    if (mongoose.Types.ObjectId.isValid(identifier)) {
        poll = await Poll.findById(identifier);
    }
    if (!poll) {
        poll = await Poll.findOne({ shortId: identifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found');
    }

    if (poll.creator.toString() !== req.user.id && req.user.role !== 'admin') {
        res.status(403);
        throw new Error('User not authorized to update this poll');
    }

    const { question, options, isPublic, expiresAt } = req.body; // Add other fields as needed
    if (question !== undefined) poll.question = question;
    if (isPublic !== undefined) poll.isPublic = isPublic;
    if (expiresAt !== undefined) poll.expiresAt = expiresAt; // Allow setting to null
    
    if (options && Array.isArray(options)) {
        // More robust option update: preserve existing votes if option text matches,
        // or reset votes if options are completely new. For simplicity:
        poll.options = options.map(opt => ({ 
            text: typeof opt === 'string' ? opt.trim() : (opt && typeof opt.text === 'string' ? opt.text.trim() : ''),
            votes: parseInt(opt.votes) || 0 // Ensure votes are numbers
        })).filter(opt => opt.text);
         if (poll.options.length < 2) {
            res.status(400);
            throw new Error('Poll must have at least two valid options after update.');
        }
    }

    const updatedPoll = await poll.save();
    res.json(updatedPoll);
});

exports.deletePoll = asyncHandler(async (req, res) => {
    const pollIdentifier = req.params.id;
    let poll;

    if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
        poll = await Poll.findById(pollIdentifier);
    }
    if (!poll && !mongoose.Types.ObjectId.isValid(pollIdentifier)) { // Only try shortId if it's not an ObjectId
        poll = await Poll.findOne({ shortId: pollIdentifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found with the given identifier.');
    }

    if (poll.creator.toString() !== req.user.id && req.user.role !== 'admin') {
        res.status(403);
        throw new Error('User not authorized to delete this poll.');
    }

    await Vote.deleteMany({ poll: poll._id }); // Delete associated votes
    await Poll.deleteOne({ _id: poll._id });

    res.json({ message: 'Poll deleted successfully' });
});

// server/controllers/pollController.js
// ... (other imports: Poll, Vote, mongoose, asyncHandler) ...
  exports.stopPoll = asyncHandler(async (req, res) => {
      const pollIdentifier = req.params.id;
      let poll;
      // ... (logic to find poll by identifier) ...
        if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
            poll = await Poll.findById(pollIdentifier);
        }
        if (!poll && !mongoose.Types.ObjectId.isValid(pollIdentifier)) {
            poll = await Poll.findOne({ shortId: pollIdentifier });
        }

        if (!poll) { /* ... handle not found ... */ }
        if (poll.creator.toString() !== req.user.id) { /* ... handle unauthorized ... */ }
        if (poll.status === 'closed') { /* ... handle already closed ... */ }

      poll.status = 'closed';
      poll.expiresAt = new Date();
      const updatedPoll = await poll.save();

      // --- Create Notifications & Prepare for Socket Emit ---
      const votes = await Vote.find({ poll: poll._id }).select('voterIdentifier').lean(); // .lean() for plain JS objects
      // Ensure voterIdentifier stores user._id for authenticated votes
      const voterUserIds = [...new Set( // Get unique voter IDs
          votes
            .map(v => v.voterIdentifier) // Get all voterIdentifiers
            .filter(id => mongoose.Types.ObjectId.isValid(id)) // Filter out invalid ones
            .map(id => id.toString()) // Convert to string for consistent comparison
      )];
      
      const usersToNotifyIds = [poll.creator.toString()]; // Start with the creator
      
      for (const userIdStr of voterUserIds) {
          // Create DB Notification for each voter (excluding creator if they also voted, handled by Set later)
          if (userIdStr !== poll.creator.toString() && !usersToNotifyIds.includes(userIdStr)) {
              usersToNotifyIds.push(userIdStr); // Add to list for socket emit
              await Notification.create({
                  userId: userIdStr, // Should be ObjectId here
                  message: `Results for the poll "${poll.question}" you voted in are now published!`,
                  link: `/poll/${poll.shortId || poll._id}/results`,
                  relatedPollId: poll._id
              });
              console.log(`DB Notification created for user ${userIdStr} for poll ${poll._id}`);
          }
      }
      // Ensure creator gets a DB notification if they didn't vote or if you want a specific one
      // (The current logic adds creator to usersToNotifyIds for socket, DB notification for creator can be separate)
      if (!voterUserIds.includes(poll.creator.toString())) {
         await Notification.create({
            userId: poll.creator,
            message: `Results for your poll "${poll.question}" are now published (you closed it).`,
            link: `/poll/${poll.shortId || poll._id}/results`,
            relatedPollId: poll._id
         });
      }
      // --- End DB Notification Creation ---


      // Emit a general 'poll_closed' event for UI updates on voting/results pages
      if (req.io) {
          const pollClosedEventData = { /* ... as before ... */ };
          req.io.to(updatedPoll._id.toString()).emit('poll_closed', pollClosedEventData);
          if (updatedPoll.shortId) req.io.to(updatedPoll.shortId).emit('poll_closed', pollClosedEventData);
          
          // Emit 'results_published_for_poll' for toast notifications
          const resultsPublishedEventData = {
              pollId: updatedPoll._id.toString(),
              pollShortId: updatedPoll.shortId,
              pollQuestion: updatedPoll.question,
              notifiedUserIds: [...new Set(usersToNotifyIds)] // Ensure unique list of user IDs
          };
          req.io.emit('results_published_for_poll', resultsPublishedEventData);
          console.log(`Emitted 'results_published_for_poll' for poll: ${updatedPoll.question} to users: ${usersToNotifyIds.join(', ')}`);
      }

      res.json(updatedPoll);
  });