// server/controllers/pollController.js
const Poll = require('../models/Poll');
const Vote = require('../models/Vote'); // Make sure this is used or remove if not
const User = require('../models/User'); // Needed if you want to fetch displayName fresh
const mongoose = require('mongoose');
const qrcode = require('qrcode');
const asyncHandler = require('express-async-handler'); // Using asyncHandler
const Notification = require('../models/Notification');
const sendEmail = require('../utils/sendEmail'); 
const crypto = require('crypto');
exports.createPoll = asyncHandler(async (req, res) => {
    const { question, options, isPublic, votingType, voteRestriction, expiresAt, showResults, allowMultipleChoices, allowedVoters,allowDeadlineLater } = req.body;
    let pollStatus = 'active'; // Default to active
    let finalExpiresAt = expiresAt;
    if (!isPublic && allowDeadlineLater) {
        pollStatus = 'scheduled'; // Override if private and deadline later
        finalExpiresAt = null;
    }
    if (!question || !options || !Array.isArray(options) || options.length < 2) {
        res.status(400); // Bad Request
        throw new Error('Question and at least two options (as an array) are required.');
    }

    // Ensure req.user exists (from protect middleware)
    if (!req.user || !req.user.id) {
        res.status(401); // Unauthorized
        throw new Error('User not authenticated or user ID missing.');
    }
    // --- DEFINE creatorId HERE, from req.user ---
    const creatorId = req.user.id; 
    // --- AND get creatorDisplayName for notifications that need it immediately ---
    let creatorDisplayNameForNotifications = req.user.displayName;
    if (!creatorDisplayNameForNotifications) { // Fallback if not on req.user directly
        const creatorDetails = await User.findById(creatorId).select('displayName');
        if (creatorDetails) {
            creatorDisplayNameForNotifications = creatorDetails.displayName;
        } else {
            creatorDisplayNameForNotifications = 'A Poll Creator'; // Generic fallback
        }
    }
    const pollOptions = options.map(opt => ({
        text: typeof opt === 'string' ? opt.trim() : (opt && typeof opt.text === 'string' ? opt.text.trim() : ''),
        votes: 0
    })).filter(opt => opt.text); // Filter out any empty options after processing

    if (pollOptions.length < 2) {
        res.status(400);
        throw new Error('At least two valid (non-empty) options are required.');
    }

    const newPoll = new Poll({
        question,
        options: pollOptions,
        creator: creatorId,
        isPublic,
        votingType: !isPublic ? 'authenticated' : (votingType || 'anonymous'), // Sensible defaults
        voteRestriction: !isPublic ? 'email' : (voteRestriction || 'none'), // Sensible defaults
        showResults: showResults || 'always', // Default
        allowMultipleChoices: allowMultipleChoices || false,
        allowedVoters: isPublic ? [] : (allowedVoters || []).map(email => email.toLowerCase().trim()).filter(Boolean),
        status: pollStatus, // status is explicitly set here
        expiresAt: finalExpiresAt,
        allowDeadlineLater: !isPublic && allowDeadlineLater,
 
    });

    // Generate QR Code
    // The shortId is generated by default by the Poll model if you used shortid.generate
    const pollUrl = `${process.env.CLIENT_URL}/poll/${newPoll.shortId}`;
    try {
        newPoll.qrCodeUrl = await qrcode.toDataURL(pollUrl);
    } catch (qrError) {
        console.error("Error generating QR code:", qrError);
        // Decide if this is a critical error. For now, we'll proceed without it.
        // You might want to throw an error or set qrCodeUrl to null.
    }

    const savedPoll = await newPoll.save();

    // Populate creator display name for the notification
    // This ensures we have the displayName even if not initially on req.user object
    // Or, ensure your 'protect' middleware populates req.user.displayName
    let creatorDisplayName = req.user.displayName;
    if (!creatorDisplayName && req.user.id) {
        const creatorDetails = await User.findById(req.user.id).select('displayName');
        if (creatorDetails) {
            creatorDisplayName = creatorDetails.displayName;
        } else {
            creatorDisplayName = 'A user'; // Fallback if user somehow not found
        }
    }


    if (!savedPoll.isPublic && savedPoll.allowedVoters && savedPoll.allowedVoters.length > 0) {
        const creator = await User.findById(creatorId).select('displayName');
        const creatorName = creator ? creator.displayName : 'The poll creator';
        const creatorNameToDisplay = creatorDisplayNameForNotifications;

        for (const invitedEmail of savedPoll.allowedVoters) { // Iterate through the emails provided
            const invitedUser = await User.findOne({ email: invitedEmail.toLowerCase() }); // Find user by this email

            if (invitedUser && invitedUser._id.toString() !== creatorId.toString()) {
                // 1. Create In-App Notification
                await Notification.create({
                    userId: invitedUser._id,
                    message: `${creatorName} has invited you to vote in the poll: "${savedPoll.question}"`,
                    link: `/poll/${savedPoll.shortId || savedPoll._id}`,
                    relatedPollId: savedPoll._id
                });

                // 2. Emit Socket Event
                if (req.io) {
                     req.io.emit('poll_invitation_sent', { 
                        invitedUserId: invitedUser._id.toString(),
                        pollId: savedPoll._id.toString(),
                        pollShortId: savedPoll.shortId,
                        pollQuestion: savedPoll.question,
                        creatorName: creatorName
                     });
                }

                // --- START: Send Email Notification ---
                try {
                    const emailMessage = `
                        <h1>You're Invited to a Poll!</h1>
                        <p>Hi ${invitedUser.displayName || 'User'},</p>
                        <p>${creatorNameToDisplay} has invited you to participate in the private poll titled: <strong>"${savedPoll.question}"</strong>.</p>
                        <p>Click the link below to view the poll and cast your vote:</p>
                        <a href="${pollUrl}" target="_blank" style="display: inline-block; padding: 10px 20px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px;">
                            Vote in Poll: ${savedPoll.question}
                        </a>
                        <p>If you did not expect this invitation, you can ignore this email.</p>
                        <br>
                        <p>Thanks,<br>The PollingApp Team</p>
                    `;
                    
                    await sendEmail({
                        to: invitedUser.email, // Send to the invited user's email
                        subject: `You've been invited to a poll by ${creatorNameToDisplay}: "${savedPoll.question}"`,
                        text: `Hi ${invitedUser.displayName || 'User'},\n\n${creatorNameToDisplay} has invited you to participate in the private poll: "${savedPoll.question}".\n\nView and vote here: ${pollUrl}\n\nThanks,\nThe PollingApp Team`,
                        html: emailMessage
                    });
                    console.log(`Email invitation sent to ${invitedUser.email} for poll "${savedPoll.question}"`);
                } catch (emailError) {
                    console.error(`Failed to send email invitation to ${invitedUser.email}:`, emailError);
                    // Decide if this failure is critical. For now, we log and continue.
                    // You might want to add specific error handling or retry logic here.
                }
                // --- END: Send Email Notification ---

            } else if (!invitedUser) {
                // Optional: Handle cases where an email in allowedVoters doesn't correspond to a registered user.
                // You might:
                // 1. Ignore it.
                // 2. Send a generic "You've been invited to a poll, sign up to participate" email.
                // 3. Store these emails somewhere for future "pending invitations" if the user registers later.
                // For now, we'll just log it.
                console.log(`No registered user found for email: ${invitedEmail}. No invitation email sent.`);
            }
        }
    }
    // --- END: Notify allowed voters ---


    if (savedPoll.isPublic && req.io) { // Existing public poll notification
         let creatorDisplayName = req.user.displayName;
         if (!creatorDisplayName && req.user.id) { 
            const creatorDetails = await User.findById(req.user.id).select('displayName');
            if (creatorDetails) creatorDisplayName = creatorDetails.displayName;
         }
         const publicPollNotification = {
            _id: savedPoll._id.toString(),
            creatorName: creatorDisplayNameForNotifications || 'A user',
            shortId: savedPoll.shortId,
            question: savedPoll.question,
            creatorName: creatorDisplayName || 'A user',
            createdAt: savedPoll.createdAt.toISOString(),
            options: savedPoll.options.map(opt => ({ text: opt.text, _id: opt._id.toString() })),
         };
         req.io.emit('new_public_poll', publicPollNotification);
    }

    res.status(201).json(savedPoll);
});



// ... (rest of your existing pollController code: getPolls, getPollById, castVote, updatePoll, deletePoll) ...
// Ensure all these functions are also wrapped with asyncHandler if they perform async operations,
// or have proper try/catch blocks.

exports.getPolls = asyncHandler(async (req, res) => {
    const polls = await Poll.find({
        isPublic: true,
        $or: [
            { expiresAt: { $gt: new Date() } },
            { expiresAt: null },
            { expiresAt: { $exists: false } } // Include polls where expiresAt is not set
        ]
    })
    .populate('creator', 'displayName email')
    .sort({ createdAt: -1 });
    res.json(polls);
});

// backend/controllers/pollController.js
exports.getPollById = asyncHandler(async (req, res) => {
    const identifier = req.params.id;
    let poll;

    console.log(`[GetPollById] Attempting to fetch poll with identifier: ${identifier}`);
    if (req.user) {
        console.log(`[GetPollById] Request has an authenticated user: ${req.user.email} (ID: ${req.user.id})`);
    } else {
        console.log(`[GetPollById] Request is from an anonymous user (req.user is not populated).`);
    }

    if (mongoose.Types.ObjectId.isValid(identifier)) {
        poll = await Poll.findById(identifier).populate('creator', 'displayName email');
    }
    // Only try findOne if findById didn't return a poll or identifier wasn't a valid ObjectId
    if (!poll && !mongoose.Types.ObjectId.isValid(identifier)) { 
        poll = await Poll.findOne({ shortId: identifier }).populate('creator', 'displayName email');
    }
    // If still no poll after trying shortId (or if it was an ObjectId but not found)
    if (!poll) { 
        console.log(`[GetPollById] Poll not found with identifier: ${identifier}`);
        res.status(404);
        throw new Error('Poll not found');
    }

    console.log(`[GetPollById] Poll found: ${poll.question}, isPublic: ${poll.isPublic}`);

    // --- Access Control Logic ---
    if (!poll.isPublic) {
        // This is a PRIVATE poll, so authentication is MANDATORY.
        // tryProtect middleware would have set req.user if a valid token was sent.
        // If req.user is not set, the user is not authenticated for this private resource.
        if (!req.user || !req.user.id) { 
            console.warn(`[GetPollById] Attempt to access private poll (${poll.shortId || poll._id}) without authentication.`);
            res.status(401); // Unauthorized - user is not logged in
            throw new Error('Authentication required to view this private poll.');
        }

        // User IS authenticated, now check if they are authorized for THIS private poll.
        const isCreator = poll.creator && poll.creator._id.toString() === req.user.id.toString();
        const isAdmin = req.user.role === 'admin';
        const userEmailForCheck = req.user.email ? req.user.email.toLowerCase() : 'MISSING_EMAIL_IN_REQ_USER'; // Defensive
        const isAllowedVoter = poll.allowedVoters.includes(userEmailForCheck);

        console.log(`[GetPollById - Private Access Check] Poll: ${poll.shortId || poll._id}, User: ${req.user.email}`);
        console.log(`[GetPollById - Private Access Check] IsCreator: ${isCreator}, IsAdmin: ${isAdmin}`);
        console.log(`[GetPollById - Private Access Check] Poll's Allowed Voters: [${poll.allowedVoters.join(', ')}]`);
        console.log(`[GetPollById - Private Access Check] User Email for Check: ${userEmailForCheck}`);
        console.log(`[GetPollById - Private Access Check] IsAllowedVoter: ${isAllowedVoter}`);

        if (!isCreator && !isAdmin && !isAllowedVoter) {
            console.warn(`[GetPollById] Forbidden access to private poll (${poll.shortId || poll._id}) by user ${req.user.email}. Not creator, admin, or allowed voter.`);
            res.status(403); // Forbidden - user is logged in but not authorized for this specific poll
            throw new Error("You don't have permission to view this private poll.");
        }
        console.log(`[GetPollById] Access GRANTED to private poll (${poll.shortId || poll._id}) for user ${req.user.email}.`);
    } else {
        // This is a PUBLIC poll. No specific user authentication is required to VIEW it.
        // req.user might be populated (if they sent a token) or null (if they didn't).
        // This is fine for viewing. Voting logic will handle restrictions.
        console.log(`[GetPollById] Access GRANTED to public poll (${poll.shortId || poll._id}). User is: ${req.user ? req.user.email : 'Anonymous'}`);
    }
    // --- END Access Control Logic ---

    res.json(poll);
});// backend/controllers/pollController.js

// ... (other requires: Poll, Vote, User, mongoose, asyncHandler, etc.) ...

exports.castVote = asyncHandler(async (req, res) => {
    const { optionIndex } = req.body;
    const pollId = req.params.id;

    // Log initial request details
    console.log(`[CastVote] Initiating vote for poll param: ${pollId}`);
    console.log(`[CastVote] Req IP (from Express): ${req.ip}`);
    console.log(`[CastVote] X-Forwarded-For Header: ${req.headers['x-forwarded-for']}`);
    console.log(`[CastVote] User-Agent: ${req.headers['user-agent']?.substring(0, 70) || 'N/A'}...`);
    if (req.user) {
        console.log(`[CastVote] Authenticated user detected: ${req.user.email} (ID: ${req.user.id})`);
    } else {
        console.log(`[CastVote] No authenticated user detected (anonymous attempt or tryProtect).`);
    }

    let pollToVoteOn;
    if (mongoose.Types.ObjectId.isValid(pollId)) {
        pollToVoteOn = await Poll.findById(pollId);
    }
    if (!pollToVoteOn) {
        pollToVoteOn = await Poll.findOne({ shortId: pollId });
    }

    if (!pollToVoteOn) {
        res.status(404);
        throw new Error('Poll not found.');
    }

    // --- Check for poll expiry and valid option (applies to all polls) ---
    if (pollToVoteOn.expiresAt && new Date(pollToVoteOn.expiresAt) < new Date()) {
        res.status(400);
        throw new Error('This poll has expired.');
    }
    if (optionIndex === undefined || optionIndex < 0 || optionIndex >= pollToVoteOn.options.length) {
        res.status(400);
        throw new Error('Invalid option selected.');
    }

    // --- Determine voterIdentifier ---
    let voterIdentifier;
    let isPublicPollVote = pollToVoteOn.isPublic;

    if (isPublicPollVote) {
        // For ALL votes on PUBLIC POLLS (logged in or anonymous):
        // Use a combination of IP and User-Agent.
        // req.ip should be the actual client IP if 'trust proxy' is set in server.js
        const userAgent = req.headers['user-agent'] || 'unknown-agent'; // Fallback for missing user-agent
        const rawIdentifierString = `${req.ip}__AGENT__${userAgent}`;
        
        // Hash the combined string to create a consistent, fixed-length identifier
        voterIdentifier = crypto.createHash('sha256').update(rawIdentifierString).digest('hex');
        
        console.log(`[CastVote] PUBLIC POLL. Using IP+UA. IP: ${req.ip}, UA: ${userAgent.substring(0,50)}...`);
        console.log(`[CastVote] PUBLIC POLL. Raw ID string for hash: "${rawIdentifierString.substring(0,100)}..."`);
        console.log(`[CastVote] PUBLIC POLL. Hashed voterIdentifier: ${voterIdentifier}`);

    } else { // PRIVATE POLL (isPublic is false)
        // Private polls strictly require authentication.
        // The 'protect' middleware should already enforce this for routes that use it.
        // If using 'tryProtect', this check is essential.
        if (!req.user || !req.user.id) {
            res.status(401);
            throw new Error('Authentication is absolutely required to vote in this private poll.');
        }

        // Access control for who can vote in this specific private poll
        const isCreator = pollToVoteOn.creator.toString() === req.user.id;
        const isAdmin = req.user.role === 'admin';
        const userEmailForCheck = req.user.email ? req.user.email.toLowerCase() : '';
        const isAllowedVoter = pollToVoteOn.allowedVoters.includes(userEmailForCheck);

        if (!isAllowedVoter && !isCreator && !isAdmin) { 
            res.status(403);
            throw new Error('You are not authorized to vote in this private poll.');
        }
        // Ensure the voting type is consistent with private poll expectations
        if (pollToVoteOn.votingType !== 'authenticated') {
            // This implies a misconfiguration, as private polls with allowedVoters should be 'authenticated' type
            console.warn(`[CastVote] Private poll ${pollToVoteOn.shortId} has votingType='${pollToVoteOn.votingType}' which is unusual for specific allowed voters.`);
            // Depending on strictness, you could throw an error or proceed using user ID.
            // For now, we proceed using user ID as it's a private poll and user is authenticated.
        }

        voterIdentifier = req.user.id; // For private polls, identifier is always user ID
        console.log(`[CastVote] PRIVATE POLL. Authenticated user voting. VoterID (user._id): ${voterIdentifier}`);
    }
    
    // --- Application-level Check for Existing Vote ---
    // This check applies to both public (IP+UA based) and private (user_id based) polls.
    const existingVote = await Vote.findOne({ poll: pollToVoteOn._id, voterIdentifier });
    if (existingVote) {
        res.status(403); // Forbidden
        throw new Error('This identifier (user/browser/IP combination) has already been used to vote on this poll.');
    }
    // --- End Check for existing vote ---

    // --- Create the Vote document ---
    try {
        await Vote.create({
            poll: pollToVoteOn._id,
            optionIndex: optionIndex,
            voterIdentifier: voterIdentifier 
        });
        console.log(`[CastVote] Vote created successfully. Poll: ${pollToVoteOn._id}, VoterIdentifier: ${voterIdentifier}`);
    } catch (dbError) {
        if (dbError.code === 11000) { // MongoDB duplicate key error
            console.warn(`[CastVote] DB Duplicate Key Error on Vote.create. Poll: ${pollToVoteOn._id}, VoterIdentifier: ${voterIdentifier}. This indicates a likely race condition or that the app-level check was bypassed.`);
            res.status(403); // Or 409 Conflict might be more appropriate
            throw new Error('Your vote could not be recorded due to a conflict. It is likely this identifier has already voted.');
        }
        console.error("[CastVote] Error during Vote.create:", dbError);
        throw dbError; // Re-throw other database errors
    }

    // --- Atomically increment the vote count and respond ---
    const updatedPoll = await Poll.findOneAndUpdate(
        { _id: pollToVoteOn._id, "options._id": pollToVoteOn.options[optionIndex]._id },
        { $inc: { "options.$.votes": 1 } },
        { new: true }
    ).populate('creator', 'displayName email');

    if (!updatedPoll) {
        // This should ideally not happen if the poll and option exist and vote was created
        console.error(`[CastVote] CRITICAL: Failed to find and update poll options after vote creation. Poll ID: ${pollToVoteOn._id}, Option Index: ${optionIndex}`);
        res.status(500);
        throw new Error('Failed to update vote count on the poll after vote creation.');
    }

    if (req.io) {
        req.io.to(updatedPoll._id.toString()).emit('vote_update', updatedPoll);
        if (updatedPoll.shortId) {
            req.io.to(updatedPoll.shortId).emit('vote_update', updatedPoll);
        }
        console.log(`[CastVote] Emitted vote_update for poll: ${updatedPoll.question}`);
    }

    res.json(updatedPoll);
});


exports.updatePoll = asyncHandler(async (req, res) => {
    // ... (Your existing logic, ensure it's robust) ...
    // Find poll by _id or shortId similarly to getPollById or castVote
    const identifier = req.params.id;
    let poll;
    if (mongoose.Types.ObjectId.isValid(identifier)) {
        poll = await Poll.findById(identifier);
    }
    if (!poll) {
        poll = await Poll.findOne({ shortId: identifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found');
    }

    if (poll.creator.toString() !== req.user.id && req.user.role !== 'admin') {
        res.status(403);
        throw new Error('User not authorized to update this poll');
    }

    const { question, options, isPublic, expiresAt } = req.body; // Add other fields as needed
    if (question !== undefined) poll.question = question;
    if (isPublic !== undefined) poll.isPublic = isPublic;
    if (expiresAt !== undefined) poll.expiresAt = expiresAt; // Allow setting to null
    
    if (options && Array.isArray(options)) {
        // More robust option update: preserve existing votes if option text matches,
        // or reset votes if options are completely new. For simplicity:
        poll.options = options.map(opt => ({ 
            text: typeof opt === 'string' ? opt.trim() : (opt && typeof opt.text === 'string' ? opt.text.trim() : ''),
            votes: parseInt(opt.votes) || 0 // Ensure votes are numbers
        })).filter(opt => opt.text);
         if (poll.options.length < 2) {
            res.status(400);
            throw new Error('Poll must have at least two valid options after update.');
        }
    }

    const updatedPoll = await poll.save();
    res.json(updatedPoll);
});

exports.deletePoll = asyncHandler(async (req, res) => {
    const pollIdentifier = req.params.id;
    let poll;

    if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
        poll = await Poll.findById(pollIdentifier);
    }
    if (!poll && !mongoose.Types.ObjectId.isValid(pollIdentifier)) { // Only try shortId if it's not an ObjectId
        poll = await Poll.findOne({ shortId: pollIdentifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found with the given identifier.');
    }

    if (poll.creator.toString() !== req.user.id && req.user.role !== 'admin') {
        res.status(403);
        throw new Error('User not authorized to delete this poll.');
    }

    await Vote.deleteMany({ poll: poll._id }); // Delete associated votes
    await Poll.deleteOne({ _id: poll._id });

    res.json({ message: 'Poll deleted successfully' });
});

// server/controllers/pollController.js
// ... (other imports: Poll, Vote, mongoose, asyncHandler) ...
  exports.stopPoll = asyncHandler(async (req, res) => {
      const pollIdentifier = req.params.id;
      let poll;
      // ... (logic to find poll by identifier) ...
        if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
            poll = await Poll.findById(pollIdentifier);
        }
        if (!poll && !mongoose.Types.ObjectId.isValid(pollIdentifier)) {
            poll = await Poll.findOne({ shortId: pollIdentifier });
        }

        if (!poll) { /* ... handle not found ... */ }
        if (poll.creator.toString() !== req.user.id) { /* ... handle unauthorized ... */ }
        if (poll.status === 'closed') { /* ... handle already closed ... */ }

      poll.status = 'closed';
      poll.expiresAt = new Date();
      const updatedPoll = await poll.save();

      // --- Create Notifications & Prepare for Socket Emit ---
      const votes = await Vote.find({ poll: poll._id }).select('voterIdentifier').lean(); // .lean() for plain JS objects
      // Ensure voterIdentifier stores user._id for authenticated votes
      const voterUserIds = [...new Set( // Get unique voter IDs
          votes
            .map(v => v.voterIdentifier) // Get all voterIdentifiers
            .filter(id => mongoose.Types.ObjectId.isValid(id)) // Filter out invalid ones
            .map(id => id.toString()) // Convert to string for consistent comparison
      )];
      
      const usersToNotifyIds = [poll.creator.toString()]; // Start with the creator
      
      for (const userIdStr of voterUserIds) {
          // Create DB Notification for each voter (excluding creator if they also voted, handled by Set later)
          if (userIdStr !== poll.creator.toString() && !usersToNotifyIds.includes(userIdStr)) {
              usersToNotifyIds.push(userIdStr); // Add to list for socket emit
              await Notification.create({
                  userId: userIdStr, // Should be ObjectId here
                  message: `Results for the poll "${poll.question}" you voted in are now published!`,
                  link: `/poll/${poll.shortId || poll._id}/results`,
                  relatedPollId: poll._id
              });
              console.log(`DB Notification created for user ${userIdStr} for poll ${poll._id}`);
          }
      }
      // Ensure creator gets a DB notification if they didn't vote or if you want a specific one
      // (The current logic adds creator to usersToNotifyIds for socket, DB notification for creator can be separate)
      if (!voterUserIds.includes(poll.creator.toString())) {
         await Notification.create({
            userId: poll.creator,
            message: `Results for your poll "${poll.question}" are now published (you closed it).`,
            link: `/poll/${poll.shortId || poll._id}/results`,
            relatedPollId: poll._id
         });
      }
      // --- End DB Notification Creation ---


      // Emit a general 'poll_closed' event for UI updates on voting/results pages
      if (req.io) {
          const pollClosedEventData = { /* ... as before ... */ };
          req.io.to(updatedPoll._id.toString()).emit('poll_closed', pollClosedEventData);
          if (updatedPoll.shortId) req.io.to(updatedPoll.shortId).emit('poll_closed', pollClosedEventData);
          
          // Emit 'results_published_for_poll' for toast notifications
          const resultsPublishedEventData = {
              pollId: updatedPoll._id.toString(),
              pollShortId: updatedPoll.shortId,
              pollQuestion: updatedPoll.question,
              notifiedUserIds: [...new Set(usersToNotifyIds)] // Ensure unique list of user IDs
          };
          req.io.emit('results_published_for_poll', resultsPublishedEventData);
          console.log(`Emitted 'results_published_for_poll' for poll: ${updatedPoll.question} to users: ${usersToNotifyIds.join(', ')}`);
      }

      res.json(updatedPoll);
  });
  exports.getUserVoteStatus = asyncHandler(async (req, res) => {
    const pollIdentifier = req.params.id;
    let poll;

    // Find the poll by _id or shortId
    if (mongoose.Types.ObjectId.isValid(pollIdentifier)) {
        poll = await Poll.findById(pollIdentifier);
    }
    if (!poll) {
        poll = await Poll.findOne({ shortId: pollIdentifier });
    }

    if (!poll) {
        res.status(404);
        throw new Error('Poll not found');
    }

    // req.user.id is from the 'protect' middleware
    const existingVote = await Vote.findOne({
        poll: poll._id,
        voterIdentifier: req.user.id // For authenticated users, voterIdentifier is their ID
    });

    res.json({ hasVoted: !!existingVote });
});
